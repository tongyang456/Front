创建一个简单的 JSX 元素
当前代码使用 JSX 将 div 元素赋值给常量 JSX。 将 div 替换为 h1 元素，并在其中添加文本 Hello JSX!。
const JSX = <h1>Hello JSX!</h1>;


创建一个复杂的 JSX 元素
定义一个新的常量 JSX，渲染一个 div，其中依次包含以下元素：
一个 h1，一个 p，一个包含三个 li 项的无序列表。 可以在每个元素中包含任意文本。
注意： 当像这样渲染多个元素时，可以把它们都用圆括号括起来，但是这并不是必须的。 
另外，此挑战使用 div 标签把所有子元素包裹在里面。 如果删除 div，JSX 将不会编译这些元素。 请记住这一点，因为在 React 组件中返回 JSX 元素时也适用。
const JSX=(<div>
  <h1></h1>
  <p></p>
  <ul>
    <li></li>
    <li></li>
    <li></li>
  </ul>
</div>)


在 JSX 中添加注释
代码编辑器中的 JSX 元素与在上一个挑战中创建的元素类似。 在提供的 div 元素里添加注释，不修改现有的 h1 或 p 元素。
const JSX = (
  <div>
    {/* aa */}
    <h1>This is a block of JSX</h1>
    <p>Here's a subtitle</p>
  </div>
);


渲染 HTML 元素为 DOM 树
代码编辑器有一个简单的 JSX 组件。 使用 ReactDOM.render() 方法将该组件渲染到页面。 
可以将定义好的 JSX 元素直接作为第一个参数传入，然后使用 document.getElementById() 来选择要渲染到的 DOM 节点， 
在这个挑战中，请渲染到 id='challenge-node'的 div 中。 确保没有修改 JSX 常量。
const JSX = (
  <div>
    <h1>Hello World</h1>
    <p>Lets render this to the DOM</p>
  </div>
);
// 在这行下面添加代码
ReactDOM.render(  
  JSX,document.getElementById('challenge-node')
)


在 JSX 中定义一个 HTML Class
现在已经习惯了编写 JSX，可能想知道它与 HTML 有什么不同。
到目前为止，HTML 和 JSX 似乎完全相同。
JSX 的一个关键区别是你不能再使用 class 这个单词来做为 HTML 的 class 名。 这是因为 class 是 JavaScript 中的关键字。 而 JSX 使用 className 来代替。
事实上，JSX 中所有 HTML 属性和事件引用的命名约定都变成了驼峰式。 例如，JSX 中的单击事件是 onClick，而不是 onclick。 
同样，onchange 变成了onChange。 虽然这是一个微小的差异，但请你一定要记住。
将 class myDiv 应用于 JSX 提供的 div上。
const JSX = (
  <div className="myDiv">
    <h1>Add a class to this div</h1>
  </div>
);


了解自闭合 JSX 标签
到目前为止，已经看到 JSX 与 HTML 的关键不同在于使用 className 还是 class 来定义 HTML 的 class。
JSX 不同于 HTML 的另一个重要方面是自闭合标签。
在HTML中，几乎所有的标签都有一个开始和结束标签：<div></div>，结束标签在你要关闭的标签名之前始终具有正斜杠。 
但是，HTML 中有一些被称为“自闭合标签”的特殊实例，它们在另一个标签开始之前，不需要开始和结束标签都存在。
例如，换行标签可以写成 <br> 或者 <br />，但是不应该写成 <br></br>，因为它不包含任何内容。
在 JSX 中，规则略有不同。 任何 JSX 元素都可以使用自闭合标签编写，并且每个元素都必须关闭。
例如，为了通过编译换行标签必须始终编写为 <br />。 另一方面 <div> 可以写成 <div /> 或者 <div></div>。 
不同之处在于，在第一个语法版本中，无法在 <div /> 中包含任何内容。 在后面的挑战中你会发现，这种语法在渲染 React 组件时非常有用。
修复代码编辑器中的错误，使其成为有效的 JSX 并成功编译。 确保不更改任何内容 -- 只需要在需要的地方关闭标签。
const JSX = (
  <div>
    <h2>Welcome to React!</h2> <br />
    <p>Be sure to close all tags!</p>
    <hr />
  </div>
);


创建一个无状态的函数组件
组件是 React 的核心。 React 中的所有内容都是一个组件，在这里将学习如何创建一个组件。
有两种方法可以创建 React 组件。 
第一种方法是使用 JavaScript 函数。 以这种方式定义组件会创建无状态函数组件。 将在以后的挑战中介绍应用程序中状态的概念。 
目前为止，可以将无状态组件视为能接收数据并对其进行渲染，但不管理或跟踪该数据的更改的组件。 (我们将下一个挑战使用中第二种方式创建 React 组件。)
要用函数创建组件，只需编写一个返回 JSX 或 null 的 JavaScript 函数。 需要注意的一点是，React 要求你的函数名以大写字母开头。 
下面是一个无状态功能组件的示例，该组件在 JSX 中分配一个 HTML 的 class：
const DemoComponent = function() {
  return (
    <div className='customClass' />
  );
};
翻译完成后， <div> 将有一个 customClass 的 CSS class。
因为 JSX 组件代表 HTML，所以你可以将几个组件放在一起以创建更复杂的 HTML 页面。 
这是 React 提供的组件架构的关键优势之一。 它允许用许多独立的组件组合成 UI。 这使得构建和维护复杂的用户界面变得更加容易。
代码编辑器中有一个名为 MyComponent 的函数。 完成此函数，使其返回包含一些文本字符串的单个 div 元素。
注意： 文本被视为是 div 的子元素，因此不能使用自闭合标签。
const MyComponent = function() {
  // 修改这行下面的代码
  return (
    <div>asas</div>
  );
  // 修改这行上面的代码
}


创建一个 React 组件
定义 React 组件的另一种方法是使用 ES6 的 class语法。 在以下示例中，Kitten 扩展了React.Component：
class Kitten extends React.Component {
  constructor(props) {
    super(props);
  }

  render() {
    return (
      <h1>Hi</h1>
    );
  }
}
这将创建一个 ES6 类 Kitten，它扩展了 React.Component 类。 
因此，Kitten 类现在可以访问许多有用的 React 功能，例如本地状态和生命周期钩子。 
如果还不熟悉这些术语，请不要担心，在以后的挑战中我们将更详细地介绍它们。 
另请注意，Kitten 类中定义了一个调用 super() 方法的 constructor。 
它使用 super() 调用父类的构造函数，即本例中的 React.Component。 
构造函数是使用 class 关键字创建的特殊方法，它在实例初始化之前调用。 
最佳做法是在组件的 constructor 里调用 super，并将 props 传递给它们， 这样可以保证组件能够正确地初始化。 
目前为止 ，需要知道这些代码是必要的。 很快会了解到到构造函数的其他用途以及 props。
MyComponent 是使用类语法在代码编辑器中定义的。 完成 render 方法的编写，使其返回 div 元素，其中包含文本内容为 Hello React! 的 h1 元素。
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
  }
  render() {
    // 修改这行下面的代码
    return (
      <div><h1>Hello React!</h1></div>
    );
    // 修改这行上面的代码
  }
};


用组合的方式创建一个 React 组件
现在来看看如何组合多个 React 组件。 想象一下，现在正在构建一个应用程序，并创建了三个组件：Navbar、Dashboard 和 Footer。
要将这些组件组合在一起，可以创建一个 App 父组件，将这三个组件分别渲染成为子组件。 
要在 React 组件中渲染一个子组件，需要在 JSX 中将组件名称写作自定义的 HTML 标签。 例如，在 render 方法中，可以这样编写：
return (
 <App>
  <Navbar />
  <Dashboard />
  <Footer />
 </App>
)
当 React 遇到一个自定义 HTML 标签引用另一个组件的时（如本例所示，组件名称包含在 < /> 中），它在自定义标签的位置渲染该组件的标签。 
这可以说明 App 组件和 Navbar、Dashboard 以及 Footer 之间的父子关系。
在代码编辑器中，有一个名为 ChildComponent 的简单函数组件和一个名为 ParentComponent 的 React 组件。 
通过在 ParentComponent 中渲染 ChildComponent 来将两者组合在一起。 确保使用正斜杠关闭 ChildComponent 标签。
Note: ChildComponent is defined with an ES6 arrow function because this is a very common practice when using React.
const ChildComponent = () => {
  return (
    <div>
      <p>I am the child</p>
    </div>
  );
};

class ParentComponent extends React.Component {
  constructor(props) {
    super(props);
  }
  render() {
    return (
      <div>
        <h1>I am the parent</h1>
        { /* 修改这行下面的代码 */ }
        <ChildComponent />
        { /* 修改这行上面的代码 */ }
      </div>
    );
  }
};


使用 React 渲染嵌套组件
上一个挑战显示了组合两个组件的简单方法，但是有许多不同的方法可以把 React 组件组合在一起。
组件组合是 React 的强大功能之一。 当使用 React 时，应当先用组件的思路考虑清楚用户界面的结构（如上一个挑战中的 App 示例）。 
可以将 UI 分解为基本的构建块，这些构建块就是组件。 这样做有助于将负责 UI 的代码与负责处理应用程序逻辑的代码分开， 并可以大大简化复杂项目的开发和维护。
代码编辑器中定义了两个功能组件，分别是 TypesOfFruit 和 Fruits。 
请用组合或者嵌套把 TypesOfFruit 组件放到 Fruits 组件中， 然后把 Fruits 组件放到 TypesOfFood 组件中。 结果应该是子组件嵌套在父组件中，父组件嵌套在它本身的父组件中！
const TypesOfFruit = () => {
  return (
    <div>
      <h2>Fruits:</h2>
      <ul>
        <li>Apples</li>
        <li>Blueberries</li>
        <li>Strawberries</li>
        <li>Bananas</li>
      </ul>
    </div>
  );
};

const Fruits = () => {
  return (
    <div>
      { /* 修改这行下面的代码 */ }
        <TypesOfFruit />
      { /* 修改这行上面的代码 */ }
    </div>
  );
};

class TypesOfFood extends React.Component {
  constructor(props) {
    super(props);
  }

  render() {
    return (
      <div>
        <h1>Types of Food:</h1>
        { /* 修改这行下面的代码 */ }
          <Fruits />
        { /* 修改这行上面的代码 */ }
      </div>
    );
  }
};


组合 React 组件
随着挑战继续，将组合使用更复杂的 React 组件和 JSX，有一点需要注意。 
在其它组件中渲染 ES6 风格的类组件和渲染在过去几个挑战中使用的简单组件没有什么不同。 可以在其它组件中渲染 JSX 元素、无状态函数组件和 ES6 类组件。
在代码编辑器中，TypesOfFood 组件已经渲染了一个名为 Vegetables 的组件。 此外，还有上次挑战中的 Fruits 组件。
在 Fruits 中嵌套两个组件，首先 NonCitrus，然后是 Citrus， 这两个组件都已经引入。 
接下来，将 Fruits 类组件嵌套到 TypesOfFood 组件中，位于 h1 标题元素下方和 Vegetables 上方。 结果应该是一系列嵌套的组件，它们使用两种不同的组件类型。
class Fruits extends React.Component {
  constructor(props) {
    super(props);
  }
  render() {
    return (
      <div>
        <h2>Fruits:</h2>
        { /* 修改这行下面的代码 */ }
        <NonCitrus />
        <Citrus />
        { /* 修改这行上面的代码 */ }
      </div>
    );
  }
};

class TypesOfFood extends React.Component {
  constructor(props) {
     super(props);
  }
  render() {
    return (
      <div>
        <h1>Types of Food:</h1>
        { /* 修改这行下面的代码 */ }
        <Fruits />
        { /* 修改这行上面的代码 */ }
        <Vegetables />
      </div>
    );
  }
};


将 class 组件渲染到 DOM 树
还记不记得在之前的挑战中使用 ReactDOM API 将 JSX 元素渲染到 DOM， 这与渲染 React 组件的过程十分相似。 
过去的几个挑战主要针对组件和组合，因此渲染是在幕后完成的。 但是，如果不调用 ReactDOM API，编写的任何 React 代码都不会渲染到 DOM。
复习一下语法： ReactDOM.render(componentToRender, targetNode)。 第一个参数是要渲染的 React 组件。 第二个参数是要在其中渲染该组件的 DOM 节点。
传递到ReactDOM.render() 的React 组件与 JSX 元素略有不同。 对于 JSX 元素，传入的是要渲染的元素的名称。 
但是，对于 React 组件，需要使用与渲染嵌套组件相同的语法，例如ReactDOM.render(<ComponentToRender />, targetNode)。 此语法用于 ES6 class 组件和函数组件都可以。
在后台引入了 Fruits 和 Vegetables 组件。 将两个组件渲染为 TypesOfFood 组件的子组件，然后将 TypesOfFood 渲染到 DOM 节点， 在这个挑战中，请渲染到 id='challenge-node'的 div 中。
class TypesOfFood extends React.Component {
  constructor(props) {
    super(props);
  }
  render() {
    return (
      <div>
        <h1>Types of Food:</h1>
        {/* 修改这行下面的代码 */}
          <Fruits />
          <Vegetables />
        {/* 修改这行上面的代码 */}
      </div>
    );
  }
};

// 修改这行下面的代码
ReactDOM.render(<TypesOfFood />, document.getElementById('challenge-node'))


从零开始写一个 React 组件
你已经了解了 JSX 和 React 组件的基础知识，是时候自己编写一个组件了。 
React 组件是 React 应用程序的核心组成部分，因此熟练编写它们是非常重要的。 
记住，典型的 React 组件是 ES6 class，它扩展了 React.Component。 
它有一个返回 HTML（从 JSX 返回）或 null 的渲染方法， 这是 React 组件的基本形式。 理解了这一点之后，就可以开始构建更复杂的 React 项目了。

定义一个 MyComponent 类，它是 React.Component 的扩展。 
它的渲染方法应该返回一个 div，其中包含一个 h1 标签，标签文本为：My First React Component!。 准确使用此文本，大小写和标点符号也要考虑。 确保也调用组件的构造器。
使用 ReactDOM.render() 把该组件渲染到 DOM 中。 有一个 id='challenge-node' 的 div 可供渲染。
// 修改这行下面的代码
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
  }

  render() {
    return (
      <div>
        <h1>My First React Component!</h1>
      </div>
    );
  }
};

ReactDOM.render(<MyComponent />, document.getElementById('challenge-node'))


将 Props 传递给无状态函数组件
之前的挑战涵盖了关于在 React 中创建和组合 JSX 元素、函数组件和 ES6 风格的类组件的很多内容。 
有了这个基础，现在是时候看看 React 中的另一个常见特性 props 了。 在 React 中，可以将属性传递给子组件。 
假设有一个 App 组件，该组件渲染了一个名为 Welcome 的子组件，它是一个无状态函数组件。 可以通过以下方式给 Welcome 传递一个 user 属性：
<App>
  <Welcome user='Mark' />
</App>
可以把创建的 React 支持的自定义 HTML 属性传递给组件。 在上面的例子里，将创建的属性 user 传递给组件 Welcome。 由于 Welcome 是一个无状态函数组件，它可以像这样访问该值：
const Welcome = (props) => <h1>Hello, {props.user}!</h1>
调用 props 这个值是常见做法，当处理无状态函数组件时，基本上可以将其视为返回 JSX 的函数的参数。 这样，你就可以在函数体中访问该值。 但对于类组件，访问方式会略有不同。
代码编辑器中有 Calendar 和 CurrentDate 组件。 
从 Calendar 组件渲染 CurrentDate 时，从 JavaScript 的 Date 对象分配当前日期，并将其作为 date 属性传入。 
然后访问 CurrentDate 组件的 prop，并在 p 标签中显示其值。 请注意，要将 prop 的值视为 JavaScript，必须将它们括在花括号中，例如date={Date()}。



